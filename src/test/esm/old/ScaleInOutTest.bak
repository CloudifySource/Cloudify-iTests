package test.esm.old;

import static org.testng.AssertJUnit.assertTrue;

import java.util.concurrent.BrokenBarrierException;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.TimeoutException;
import java.util.concurrent.atomic.AtomicBoolean;
import java.util.concurrent.atomic.AtomicInteger;

import org.openspaces.admin.esm.ElasticServiceManager;
import org.openspaces.admin.gsc.GridServiceContainer;
import org.openspaces.admin.gsc.events.GridServiceContainerLifecycleEventListener;
import org.openspaces.admin.pu.ProcessingUnit;
import org.openspaces.admin.pu.events.ProcessingUnitStatusChangedEvent;
import org.openspaces.admin.pu.events.ProcessingUnitStatusChangedEventListener;
import org.openspaces.core.GigaSpace;
import org.testng.annotations.BeforeMethod;
import org.testng.annotations.Test;

import test.AbstractTest;
import test.utils.ThreadBarrier;

/***
 * this test is meant to check the ESM functionality,
 * minGsc,maxGsc variables are declared and ElasticDataGridDeployment is deployed based on those variables.
 * a feeder task is then executed and feeds the gscs with objects until "maxGscsExpected" gscs are running.
 * now, the spaces are cleared with the intention of reducing memory below the threshold so that the esm can close gscs
 * and only minGscsExpected are expected to remain. 
 */

public class ScaleInOutTest extends AbstractTest {

	private long testTimeOut = 1000 * 60 * 5; //5 minutes
	private int minGscsExpected = 2;
	private int maxGscsExpected = 8;
	
	private GigaSpace gigaSpace;
	private ThreadBarrier barrier;
	private AtomicInteger maxGscsOnRun;
	private AtomicInteger minGscsOnRun;
	private int numOfObjToWrite;
	private AtomicBoolean shouldStop;
	private GridServiceContainerLifecycleEventListener GSCLifeCycleListener;
	public ScaleInOutTest(){
		super();
	}
	
	//@BeforeMethod
	public void setup(){
		maxGscsOnRun = new AtomicInteger(0);
		minGscsOnRun = new AtomicInteger(8);
		shouldStop = new AtomicBoolean(false);
		GSCLifeCycleListener = new GridServiceContainerLifecycleEventListener(){
			public void gridServiceContainerAdded(
					GridServiceContainer gridServiceContainer) {
				maxGscsOnRun.set(Math.max(admin.getGridServiceContainers().getSize(),maxGscsOnRun.get()));
				
			}

			public void gridServiceContainerRemoved(
					GridServiceContainer gridServiceContainer) {
				minGscsOnRun.set(Math.min(admin.getGridServiceContainers().getSize(),minGscsOnRun.get()));
			}
		};
		admin.getMachines().waitFor(4);
		admin.addEventListener(GSCLifeCycleListener);
		
		admin.addEventListener(new ProcessingUnitStatusChangedEventListener() {
			
			public void processingUnitStatusChanged(
					ProcessingUnitStatusChangedEvent event) {
				assertTrue("max gscs should be less than or equals to "+maxGscsExpected+" while it is "+maxGscsOnRun.get(),maxGscsOnRun.get()<=maxGscsExpected);
				assertTrue("min gscs should be more than or equals to "+minGscsExpected+" while it is "+minGscsOnRun.get(),minGscsOnRun.get()>=minGscsExpected);
			}
		}); 
	}
		
	public void testBody(String javaHeapSize,String threshold){
				
		ElasticServiceManager esm= admin.getElasticServiceManagers().waitForAtLeastOne();
		ProcessingUnit pu = EsmTestsUtils.deployElasticDataGrid(esm, minGscsExpected, maxGscsExpected, javaHeapSize, threshold);
		
        gigaSpace = pu.getSpace().getGigaSpace();
       
        barrier = new ThreadBarrier(2);
        
        Thread t=new MyThread(new FeedAndTakeTask());
        t.start();
        
     
    	try {
			barrier.await(testTimeOut,TimeUnit.MILLISECONDS);
		} catch (InterruptedException e) {
			e.printStackTrace();
		} catch (BrokenBarrierException e) {
			e.printStackTrace();
		} catch (TimeoutException e) {
		}
		shouldStop.set(true);	
		admin.removeEventListener(GSCLifeCycleListener);
		assertTrue("max gscs should be less than or equals to "+maxGscsExpected+" while it is "+maxGscsOnRun.get(),maxGscsOnRun.get()<=maxGscsExpected);
		assertTrue("min gscs should be more than or equals to "+minGscsExpected+" while it is "+minGscsOnRun.get(),minGscsOnRun.get()>=minGscsExpected);
    	
	}
	
	@Test(timeOut = DEFAULT_TEST_TIMEOUT ,groups="2")
	public void test(){
		String javaHeapSize = "1g";
		String threshold = "25%";
		numOfObjToWrite = 5000;
		this.testBody(javaHeapSize, threshold);
	}
	
	@Test(timeOut = DEFAULT_TEST_TIMEOUT ,groups="2")
	public void test2() throws InterruptedException{
		String javaHeapSize = "2g";
		String threshold = "70%";
		numOfObjToWrite = 20000;
		this.testBody(javaHeapSize, threshold);
	}
	
	public class FeedAndTakeTask implements Runnable{
						
		public void run() {
			while(!shouldStop.get()){
				/**
				 * if maxGscsExpected are running then stop feeding and start cleaning the spaces
				 */
				if (admin.getGridServiceContainers().getSize()>=maxGscsExpected){
					assertTrue("max gscs should be "+maxGscsExpected+" while it is "+maxGscsOnRun.get(),maxGscsOnRun.get()==maxGscsExpected);
					EsmTestsUtils.cleanCluster(admin);
					shouldStop.set(true);
					barrier.reset();
				}else{
					EsmTestsUtils.writeBatch(gigaSpace, numOfObjToWrite,numOfObjToWrite/2);
				}
			}
		}
	}
	
    /**
     * @author anna
     * @since 7.1
     */
    public class MyThread
            extends Thread
    {

        /**
         * @param target
         */
        public MyThread(Runnable target)
        {
            super(target);

        }

        /* (non-Javadoc)
         * @see java.lang.Thread#interrupt()
         */
        @Override
        public void interrupt()
        {
            System.out.println("********** MyThread interrupted ************");

            new Exception().printStackTrace();
            super.interrupt();
        }

}
}

